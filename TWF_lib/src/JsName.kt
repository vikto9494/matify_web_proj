import config.CompiledConfiguration
import config.FunctionConfiguration
import expressiontree.ExpressionNode
import expressiontree.ExpressionNodeConstructor
import expressiontree.ExpressionSubstitution
import expressiontree.SubstitutionSelectionData
import expressiontree.fillSubstitutionSelectionData
import expressiontree.applySubstitution
import expressiontree.generateSubstitutionsBySelectedNodes
import expressiontree.NodeType

@JsName("structureStringToExpression")
fun structureStringToExpression(
        structureString: String,
        scope: String = "",
        functionConfiguration: FunctionConfiguration = FunctionConfiguration(
                scopeFilter = scope.split(";").filter { it.isNotEmpty() }.toSet()
        )
): ExpressionNode {
    val expressionNodeConstructor = ExpressionNodeConstructor(functionConfiguration)
    val result = expressionNodeConstructor.construct(structureString)
    result.computeNodeIdsAsNumbersInDirectTraversalAndDistancesToRoot()
    result.computeIdentifier()
    return result
}

@JsName("createCompiledConfigurationFromExpressionSubstitutionsAndParams")
fun createCompiledConfigurationFromExpressionSubstitutionsAndParams (
        expressionSubstitutions: Array<ExpressionSubstitution>,
        additionalParamsMap: Map<String, String> = mapOf()
) = CompiledConfiguration(additionalParamsMap = additionalParamsMap).apply {
    compiledExpressionTreeTransformationRules.clear()
    compiledExpressionSimpleAdditionalTreeTransformationRules.clear()
    val handledCodesHashSet = hashSetOf<String>()
    for (substitution in expressionSubstitutions){
        if (handledCodesHashSet.contains(substitution.code))
            continue
        handledCodesHashSet.add(substitution.code)
        if (substitution.left.nodeType == NodeType.EMPTY || substitution.right.nodeType == NodeType.EMPTY) {
            if (substitution.code.isNotEmpty()) {
                expressionTreeAutogeneratedTransformationRuledentifiers.put(substitution.code, substitution)
            }
        } else {
            compiledExpressionTreeTransformationRules.add(substitution)
            if (substitution.simpleAdditional) {
                compiledExpressionSimpleAdditionalTreeTransformationRules.add(substitution)
            }
        }
    }
}

@JsName("expressionSubstitutionFromStructureStrings")
fun expressionSubstitutionFromStructureStrings(
        leftStructureString: String = "",
        rightStructureString: String = "",
        basedOnTaskContext: Boolean = false,
        matchJumbledAndNested: Boolean = false,
        simpleAdditional: Boolean = false,
        isExtending: Boolean = false,
        priority: Int = 50,
        code: String = "",
        nameEn: String = "",
        nameRu: String = ""
) = ExpressionSubstitution(
        if (leftStructureString.isNotBlank()) api.structureStringToExpression(leftStructureString) else ExpressionNode(NodeType.EMPTY, ""),
        if (rightStructureString.isNotBlank()) api.structureStringToExpression(rightStructureString) else ExpressionNode(NodeType.EMPTY, ""),
        basedOnTaskContext = basedOnTaskContext,
        matchJumbledAndNested = matchJumbledAndNested,
        simpleAdditional = simpleAdditional,
        isExtending = isExtending,
        priority = priority,
        code = if (code.isNotBlank()) code else "'$leftStructureString'->'$rightStructureString'",
        nameEn = nameEn,
        nameRu = nameRu
)

@JsName("applySubstitutionInSelectedPlace")
fun applySubstitutionInSelectedPlace (
        expression: ExpressionNode,
        selectedNodeIds: Array<Int>,
        substitution: ExpressionSubstitution,
        compiledConfiguration: CompiledConfiguration,
        simplifyNotSelectedTopArguments: Boolean = false
): ExpressionNode? {
    val substitutionSelectionData = SubstitutionSelectionData(expression, selectedNodeIds, compiledConfiguration)
    fillSubstitutionSelectionData(substitutionSelectionData)
    return applySubstitution(substitutionSelectionData, substitution, simplifyNotSelectedTopArguments)
}

@JsName("findApplicableSubstitutionsInSelectedPlace")
fun findApplicableSubstitutionsInSelectedPlace (
        expression: ExpressionNode,
        selectedNodeIds: Array<Int>,
        compiledConfiguration: CompiledConfiguration,
        simplifyNotSelectedTopArguments: Boolean = false,
        withReadyApplicationResult: Boolean = true
) = generateSubstitutionsBySelectedNodes(
        SubstitutionSelectionData(expression, selectedNodeIds, compiledConfiguration),
        withReadyApplicationResult = withReadyApplicationResult
)
